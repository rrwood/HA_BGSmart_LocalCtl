"""
BG Smart Local Control Integration for Home Assistant
Based on ESP Local Control protocol (reverse engineered from BG Smart app)
"""

# PROTOCOL DETAILS (from reverse engineering):
# - Endpoint: http://[device-ip]:[port]/esp_local_ctrl/control
# - Default port: 80
# - Protocol: HTTP POST with protobuf payload
# - Security: sec0 (no encryption) or sec1 (encrypted with PoP key)
# - Properties: Device has 2 properties:
#   - Index 0: "config" (device configuration, node_id, etc.)
#   - Index 1: "params" (device parameters - brightness, power, etc.)
# - Property format: JSON encoded as bytes in protobuf

# __init__.py
import logging
from homeassistant.config_entries import ConfigEntry
from homeassistant.core import HomeAssistant

_LOGGER = logging.getLogger(__name__)

DOMAIN = "bg_smart_local"
PLATFORMS = ["light"]

async def async_setup(hass: HomeAssistant, config: dict):
    """Set up the BG Smart Local component."""
    hass.data.setdefault(DOMAIN, {})
    return True

async def async_setup_entry(hass: HomeAssistant, entry: ConfigEntry):
    """Set up BG Smart Local from a config entry."""
    from .esp_local_control import ESPLocalDevice
    
    host = entry.data["host"]
    port = entry.data.get("port", 80)
    node_id = entry.data.get("node_id", "")
    pop = entry.data.get("pop", "")
    security_type = entry.data.get("security_type", 0)  # 0 = sec0, 1 = sec1
    
    device = ESPLocalDevice(host, port, node_id, pop, security_type)
    
    hass.data[DOMAIN][entry.entry_id] = {
        "device": device,
        "host": host,
        "port": port
    }
    
    await hass.config_entries.async_forward_entry_setups(entry, PLATFORMS)
    return True

async def async_unload_entry(hass: HomeAssistant, entry: ConfigEntry):
    """Unload a config entry."""
    unload_ok = await hass.config_entries.async_unload_platforms(entry, PLATFORMS)
    
    if unload_ok:
        hass.data[DOMAIN].pop(entry.entry_id)
    
    return unload_ok


# manifest.json
MANIFEST = {
    "domain": "bg_smart_local",
    "name": "BG Smart Local Control",
    "documentation": "https://github.com/yourusername/bg_smart_local",
    "requirements": ["protobuf>=3.20.0"],
    "codeowners": ["@yourusername"],
    "version": "0.1.0",
    "config_flow": True,
    "iot_class": "local_polling"
}


# config_flow.py
import voluptuous as vol
from homeassistant import config_entries
from homeassistant.core import callback

class BGSmartLocalFlowHandler(config_entries.ConfigFlow, domain=DOMAIN):
    """Handle a config flow for BG Smart Local Control."""
    
    VERSION = 1
    
    async def async_step_user(self, user_input=None):
        """Handle the initial step."""
        errors = {}
        
        if user_input is not None:
            # Test connection
            from .esp_local_control import ESPLocalDevice
            device = ESPLocalDevice(
                user_input["host"],
                user_input.get("port", 80),
                user_input.get("node_id", ""),
                user_input.get("pop", ""),
                user_input.get("security_type", 0)
            )
            
            try:
                # Try to get property count to verify connection
                count = await device.get_property_count()
                if count > 0:
                    return self.async_create_entry(
                        title=f"BG Smart Dimmer ({user_input['host']})",
                        data=user_input
                    )
                else:
                    errors["base"] = "cannot_connect"
            except Exception:
                errors["base"] = "cannot_connect"
        
        data_schema = vol.Schema({
            vol.Required("host"): str,
            vol.Optional("port", default=80): int,
            vol.Optional("node_id", default=""): str,
            vol.Optional("pop", default=""): str,
            vol.Optional("security_type", default=0): vol.In([0, 1]),
        })
        
        return self.async_show_form(
            step_id="user",
            data_schema=data_schema,
            errors=errors
        )


# esp_local_control.py
import asyncio
import json
import logging
from typing import Optional, Dict, Any

import aiohttp

# Import the protobuf messages (generated from esp_local_ctrl.proto)
from .esp_local_ctrl_pb2 import (
    LocalCtrlMessage,
    LocalCtrlMsgType,
    CmdGetPropertyCount,
    CmdGetPropertyValues,
    CmdSetPropertyValues,
    PropertyValue
)

_LOGGER = logging.getLogger(__name__)

class ESPLocalDevice:
    """ESP Local Control Device."""
    
    def __init__(self, host: str, port: int, node_id: str, pop: str, security_type: int):
        self.host = host
        self.port = port
        self.node_id = node_id
        self.pop = pop
        self.security_type = security_type
        self.base_url = f"http://{host}:{port}"
        self.control_path = "esp_local_ctrl/control"
        self.property_count = -1
        self._params_cache = {}
    
    async def _send_request(self, message: LocalCtrlMessage) -> Optional[LocalCtrlMessage]:
        """Send a protobuf request to the device."""
        url = f"{self.base_url}/{self.control_path}"
        payload = message.SerializeToString()
        
        headers = {
            "Content-Type": "application/x-www-form-urlencoded",
            "Accept": "text/plain",
            "Connection": "Keep-Alive"
        }
        
        try:
            async with aiohttp.ClientSession() as session:
                async with session.post(url, data=payload, headers=headers, timeout=aiohttp.ClientTimeout(total=10)) as response:
                    if response.status == 200:
                        body = await response.read()
                        return LocalCtrlMessage.FromString(body)
                    else:
                        _LOGGER.error(f"HTTP error: {response.status}")
                        return None
        except Exception as e:
            _LOGGER.error(f"Failed to send request: {e}")
            return None
    
    async def get_property_count(self) -> int:
        """Get the number of properties."""
        if self.property_count > 0:
            return self.property_count
        
        message = LocalCtrlMessage(
            msg=LocalCtrlMsgType.TypeCmdGetPropertyCount,
            cmd_get_prop_count=CmdGetPropertyCount()
        )
        
        response = await self._send_request(message)
        if response and response.HasField('resp_get_prop_count'):
            self.property_count = response.resp_get_prop_count.count
            return self.property_count
        
        return -1
    
    async def get_property_values(self) -> Optional[Dict[str, Any]]:
        """Get all property values."""
        count = await self.get_property_count()
        if count <= 0:
            return None
        
        # Request all properties (indices 0 to count-1)
        message = LocalCtrlMessage(
            msg=LocalCtrlMsgType.TypeCmdGetPropertyValues,
            cmd_get_prop_vals=CmdGetPropertyValues(
                indices=list(range(count))
            )
        )
        
        response = await self._send_request(message)
        if not response or not response.HasField('resp_get_prop_vals'):
            return None
        
        properties = {}
        for prop_info in response.resp_get_prop_vals.props:
            try:
                # Decode the JSON value
                value_json = json.loads(prop_info.value.decode('utf-8'))
                properties[prop_info.name] = value_json
                
                # Cache params for quick access
                if prop_info.name == "params":
                    self._params_cache = value_json
                    
            except Exception as e:
                _LOGGER.error(f"Failed to parse property {prop_info.name}: {e}")
        
        return properties
    
    async def set_property_values(self, params_json: Dict[str, Any]) -> bool:
        """Set device parameters."""
        # Property at index 1 is "params" which contains device controls
        json_str = json.dumps(params_json)
        
        message = LocalCtrlMessage(
            msg=LocalCtrlMsgType.TypeCmdSetPropertyValues,
            cmd_set_prop_vals=CmdSetPropertyValues(
                props=[
                    PropertyValue(
                        index=1,  # Index 1 is always "params"
                        value=json_str.encode('utf-8')
                    )
                ]
            )
        )
        
        response = await self._send_request(message)
        if response and response.HasField('resp_set_prop_vals'):
            success = response.resp_set_prop_vals.status == 0  # 0 = Success
            if success:
                # Update cache
                for key, value in params_json.items():
                    if key in self._params_cache:
                        self._params_cache[key].update(value)
            return success
        
        return False
    
    async def get_params(self) -> Dict[str, Any]:
        """Get current device params (brightness, power, etc.)."""
        if not self._params_cache:
            properties = await self.get_property_values()
            if properties and "params" in properties:
                self._params_cache = properties["params"]
        
        return self._params_cache
    
    async def set_param(self, device_name: str, param_name: str, value: Any) -> bool:
        """Set a specific parameter."""
        # BG Smart dimmers use nested JSON: {"DeviceName": {"param": value}}
        params = {
            device_name: {
                param_name: value
            }
        }
        return await self.set_property_values(params)


# light.py
import logging
from typing import Any
from homeassistant.components.light import (
    ATTR_BRIGHTNESS,
    ColorMode,
    LightEntity,
)
from homeassistant.config_entries import ConfigEntry
from homeassistant.core import HomeAssistant
from homeassistant.helpers.entity_platform import AddEntitiesCallback

_LOGGER = logging.getLogger(__name__)

async def async_setup_entry(
    hass: HomeAssistant,
    entry: ConfigEntry,
    async_add_entities: AddEntitiesCallback,
):
    """Set up BG Smart lights."""
    data = hass.data[DOMAIN][entry.entry_id]
    device = data["device"]
    
    # Get device parameters to discover devices
    try:
        params = await device.get_params()
        
        # Create a light entity for each device in params
        entities = []
        for device_name in params.keys():
            entities.append(BGSmartDimmer(device, device_name, entry))
        
        async_add_entities(entities)
    except Exception as e:
        _LOGGER.error(f"Failed to set up lights: {e}")


class BGSmartDimmer(LightEntity):
    """Representation of a BG Smart Dimmer."""
    
    def __init__(self, device, device_name: str, entry: ConfigEntry):
        """Initialize the dimmer."""
        self._device = device
        self._device_name = device_name
        self._attr_unique_id = f"{entry.entry_id}_{device_name}"
        self._attr_name = f"BG Smart {device_name}"
        self._attr_supported_color_modes = {ColorMode.BRIGHTNESS}
        self._attr_color_mode = ColorMode.BRIGHTNESS
        self._state = None
        self._brightness = None
    
    @property
    def is_on(self):
        """Return if the light is on."""
        return self._state
    
    @property
    def brightness(self):
        """Return the brightness (0-255)."""
        if self._brightness is None:
            return None
        # Convert from 0-100 to 0-255
        return int(self._brightness * 2.55)
    
    async def async_turn_on(self, **kwargs):
        """Turn on the light."""
        brightness = kwargs.get(ATTR_BRIGHTNESS)
        
        # Determine brightness value to send (0-100)
        if brightness is not None:
            brightness_pct = int(brightness / 2.55)
        else:
            brightness_pct = 100  # Default to full brightness
        
        # Set both Power and Brightness parameters
        success = await self._device.set_param(
            self._device_name,
            "Power",
            {"power": 1}  # Turn on
        )
        
        if success and brightness is not None:
            success = await self._device.set_param(
                self._device_name,
                "Brightness",
                {"brightness": brightness_pct}
            )
        
        if success:
            self._state = True
            if brightness is not None:
                self._brightness = brightness_pct
            self.async_write_ha_state()
    
    async def async_turn_off(self, **kwargs):
        """Turn off the light."""
        success = await self._device.set_param(
            self._device_name,
            "Power",
            {"power": 0}  # Turn off
        )
        
        if success:
            self._state = False
            self.async_write_ha_state()
    
    async def async_update(self):
        """Fetch new state data for this light."""
        try:
            params = await self._device.get_params()
            if self._device_name in params:
                device_params = params[self._device_name]
                
                # Check for Power parameter
                if "Power" in device_params:
                    self._state = device_params["Power"].get("power", 0) == 1
                
                # Check for Brightness parameter
                if "Brightness" in device_params:
                    self._brightness = device_params["Brightness"].get("brightness", 0)
                    
        except Exception as e:
            _LOGGER.error(f"Failed to update device state: {e}")


# strings.json
STRINGS = {
    "config": {
        "step": {
            "user": {
                "title": "BG Smart Local Control",
                "description": "Connect to your BG Smart dimmer on the local network",
                "data": {
                    "host": "IP Address",
                    "port": "Port",
                    "node_id": "Node ID (optional)",
                    "pop": "Proof of Possession (optional)",
                    "security_type": "Security Type (0=None, 1=Sec1)"
                }
            }
        },
        "error": {
            "cannot_connect": "Failed to connect to device"
        }
    }
}
